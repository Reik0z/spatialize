import threading
from multiprocessing import Manager

import numpy as np
from joblib import Parallel, delayed
from sklearn.mixture import BayesianGaussianMixture, GaussianMixture
from sklearn.neighbors import KernelDensity
from sklearn.exceptions import ConvergenceWarning

# just to turn warnings off
import warnings

from spatialize import logging
from spatialize.gs.spa.empirical import FittedModelFactory, EmpiricalModel
from spatialize.logging import log_message, default_singleton_callback
from spatialize.viz import plot_colormap_array

warnings.filterwarnings("ignore", category=ConvergenceWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)


class ESSResult:
    """
    A class to represent the result of Ensemble Spatial Simulation (ESS).

    This class contains the scenarios generated by the Ensemble Spatial Simulation
    method (ESS), based on a set of ESI (Ensemble Spatial Interpolation) samples. It
    provides methods for visualizing and interacting with the simulation scenarios
    generated for a given estimation result.

    Attributes
    ----------
    esi_result
        The result of the Ensemble Spatial Interpolation (ESI) estimation used
        to generate the ESS scenarios.
    scenarios
        A 2D array where each row represents a simulated scenario based on the
        ESI samples.
    desc
        A description of the ESS result, which is used for labeling and identification.

    Methods
    -------
    quick_plot(n_imgs=9, n_cols=3, norm_lims=False, title_prefix="scenario", title=None):
        Plots a quick preview of the ESS scenarios as a grid of colormap images.
    """

    def __init__(self, ess_scenarios, esi_result, desc):
        """
        Initializes an ESSResult instance.

        :param ess_scenarios: The set of simulated ESS scenarios.
        :param esi_result: The ESI result used for generating the ESS scenarios.
        :param desc: A description of the ESS result.
        """
        self.esi_result = esi_result
        self.scenarios = ess_scenarios
        self.desc = desc

    def __repr__(self):
        return str(self.desc)

    def quick_plot(self, n_imgs=9, n_cols=3, norm_lims=False, title_prefix="scenario", title=None):
        """
        Quickly plots a preview of the ESS scenarios as a grid of colormap images.

        This method utilizes the `plot_colormap_array` function to display the specified
        number of simulated ESS scenarios. Each scenario is represented as an image in
        the grid layout.

        :param n_imgs: The number of ESS scenarios (images) to display. Defaults to 9.
        :param n_cols: The number of columns in the grid layout. Defaults to 3.
        :param norm_lims: Whether to normalize the values of the scenarios based on the reference map. Defaults to False.
        :param title_prefix: The prefix to use in the subplot titles (e.g., "scenario 1", "scenario 2"). Defaults to "scenario".
        :param title: The title for the entire plot. Defaults to None, which uses the `desc` attribute.

        :return: A Matplotlib figure containing the grid of ESS scenario plots.
        """
        if title is None:
            title = self.desc
        return plot_colormap_array(self.scenarios, n_imgs=n_imgs,
                                   n_cols=n_cols, norm_lims=norm_lims,
                                   xi_locations=self.esi_result._xi,
                                   reference_map=self.esi_result.estimation(),
                                   title_prefix=title_prefix,
                                   title=title)


def ess_sample(esi_result,
               n_sims=100,
               fitted_model_factory=FittedModelFactory(),
               desc=None,
               n_jobs=-1,
               callback=default_singleton_callback):
    """
        Generate simulated scenarios from Ensemble Spatial Interpolation (ESI) samples using probabilistic models.

        This function takes ESI (Ensemble Spatial Interpolation) samples from the provided ``esi_result``,
        fits a probabilistic model to each sample using a specified model factory, and generates a specified
        number of simulations per sample. Execution can be done serially or in parallel, with real-time progress
        tracking via a callback.

        :param esi_result:
            An object containing ESI (Ensemble Spatial Interpolation) samples. Must implement
            the method ``esi_samples(raw=True)`` which returns a NumPy array of shape
            ``(n_samples, n_features)``.
        :type esi_result: object
        :param n_sims:
            Number of simulations to generate per ESI sample.
        :type n_sims: int, optional
        :param fitted_model_factory:
            A factory for creating fitted probabilistic models per sample. Must provide
            a ``create(...)`` method and define ``point_model_name`` and other relevant attributes.
        :type fitted_model_factory: FittedModelFactory, optional
        :param desc:
            Optional textual description for the result. If not provided, it will be generated
            based on the model type and simulation parameters.
        :type desc: str, optional
        :param n_jobs:
            Number of parallel jobs to use. Set to ``1`` for serial execution or ``-1`` to use all available CPUs.
        :type n_jobs: int, optional
        :param callback:
            A callback function for progress reporting. Expected to support ``logging.progress.init``,
            ``inform``, and ``stop`` methods.
        :type callback: callable, optional
        :returns:
            An ``ESSResult`` object containing the simulated scenarios, the original ESI result,
            and a textual description.
        :rtype: ESSResult
        :raises ValueError:
            If the model type specified in ``fitted_model_factory.point_model_name`` is not one of
            ``"vim"``, ``"emm"``, or ``"kde"``.
        .. note::
            - This function supports parallel execution using ``joblib.Parallel`` and includes a separate
              thread for real-time progress monitoring.
            - It is designed for large-scale scenario generation from spatial ensemble data.
        .. warning::
            - If model fitting or sampling fails for a given sample, its corresponding scenario row is
              replaced with zeros.
            - When using ``n_jobs != 1``, this function must be called within a
              ``if __name__ == "__main__":`` block to avoid multiprocessing issues
              (especially on Windows and macOS).
    """
    # work always with the flattened array just to support arbitrary dimensions
    esi_samples = np.array(esi_result.esi_samples(raw=True))

    log_message(logging.logger.debug(f"esi_samples shape: {esi_samples.shape}"))

    def run_serial():
        scenarios = np.empty([esi_samples.shape[0], n_sims])
        callback(logging.progress.init(esi_samples.shape[0], 1))
        for esi_sample_idx in range(esi_samples.shape[0]):
            model, _ = fitted_model_factory.create(esi_samples[esi_sample_idx, :])

            # sampling from the fitted model
            if fitted_model_factory.point_model_name in {"vim", "emm"}:
                s = model.sample(n_sims)[0].reshape(1, n_sims)[0]
            elif fitted_model_factory.point_model_name == "kde":
                s = model.sample(n_sims).reshape(1, n_sims)[0]
            else:
                raise ValueError(f"Unsupported model type: {fitted_model_factory.point_model_name}")

            scenarios[esi_sample_idx, :] = s[:]
            callback(logging.progress.inform())
        callback(logging.progress.stop())
        return scenarios

    # to run in parallel ------------------------------------------------------------------------
    def sample_single_scenario(idx, sample_row, n_sims, model_factory, progress_q):
        try:
            model, _ = model_factory.create(sample_row)

            # Sample based on model type
            if model_factory.point_model_name in {"vim", "emm"}:
                sims = model.sample(n_sims)[0].reshape(n_sims)
            elif model_factory.point_model_name == "kde":
                sims = model.sample(n_sims).reshape(n_sims)
            else:
                raise ValueError(f"Unsupported model type: {model_factory.point_model_name}")

            if progress_q:
                progress_q.put(1)
            return idx, sims

        except Exception as e:
            logging.logger.debug(f"Sampling failed for sample[{idx}]: {e}")
            if progress_q:
                progress_q.put(1)
            return idx, None

    def run_parallel():
        def progress_monitor(queue, total, cb):
            count = 0
            cb(logging.progress.init(total, 1))
            while count < total:
                queue.get()
                count += 1
                cb(logging.progress.inform())
            cb(logging.progress.stop())

        with Manager() as manager:
            progress_queue = manager.Queue()

            monitor_thread = threading.Thread(
                target=progress_monitor,
                args=(progress_queue, esi_samples.shape[0], callback),
                daemon=True
            )
            monitor_thread.start()

            results = Parallel(n_jobs=n_jobs, backend='loky')(
                delayed(sample_single_scenario)(
                    i, esi_samples[i, :], n_sims, fitted_model_factory, progress_queue
                )
                for i in range(esi_samples.shape[0])
            )

            monitor_thread.join()

        # Sort results and construct the scenarios array
        sorted_results = sorted(results, key=lambda x: x[0])
        valid_scenarios = [r[1] if r[1] is not None else np.zeros(n_sims) for r in sorted_results]
        scenarios = np.stack(valid_scenarios)

        return scenarios

    if n_jobs == 1:
        scenarios = run_serial()
    else:
        scenarios = run_parallel()

    if desc is None:
        if fitted_model_factory.point_model_name == "kde":
            desc = f"{n_sims}sims_kde_{fitted_model_factory.kernel}"
        else:
            desc = f"{n_sims}sims_{fitted_model_factory.point_model_name}_{fitted_model_factory.n_components}_components"

    return ESSResult(scenarios, esi_result, desc)
